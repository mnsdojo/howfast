{
  "paragraphs": [
    "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"Hello, World!\")\n}",
    "for i := 0; i < 10; i++ {\n\tfmt.Println(i)\n}",
    "func add(a int, b int) int {\n\treturn a + b\n}",
    "type Person struct {\n\tName string\n\tAge  int\n}",
    "def factorial(n):\n\tif n == 0:\n\t\treturn 1\n\telse:\n\t\treturn n * factorial(n-1)",
    "print('Hello, World!')",
    "for i in range(10):\n\tprint(i)",
    "class Animal:\n\tdef __init__(self, name):\n\t\tself.name = name",
    "const greet = () => {\n\tconsole.log('Hello, World!');\n};",
    "function add(a, b) {\n\treturn a + b;\n}",
    "class Animal {\n\tconstructor(name) {\n\t\tthis.name = name;\n\t}\n}",
    "int main() {\n\tprintf(\"Hello, World!\");\n\treturn 0;\n}",
    "let numbers = [1, 2, 3];\nnumbers.forEach(num => console.log(num));",
    "if x > 10:\n\tprint('x is greater than 10')",
    "func fibonacci(n int) int {\n\tif n <= 1 {\n\t\treturn n\n\t}\n\treturn fibonacci(n-1) + fibonacci(n-2)\n}",
    "def is_prime(n):\n\tif n <= 1:\n\t\treturn False\n\tfor i in range(2, int(n**0.5) + 1):\n\t\tif n % i == 0:\n\t\t\treturn False\n\treturn True",
    "const numbers = [1, 2, 3, 4, 5];\nconst squares = numbers.map(num => num * num);",
    "class Car {\n\tconstructor(brand) {\n\t\tthis.brand = brand;\n\t}\n\tdisplay() {\n\t\tconsole.log(this.brand);\n\t}\n}",
    "int factorial(int n) {\n\tif (n == 0) {\n\t\treturn 1;\n\t}\n\treturn n * factorial(n - 1);\n}",
    "def greet(name):\n\tprint(f'Hello, {name}!')",
    "func reverseString(s string) string {\n\trunes := []rune(s)\n\tfor i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n\t\trunes[i], runes[j] = runes[j], runes[i]\n\t}\n\treturn string(runes)\n}",
    "const user = {\n\tname: 'Alice',\n\tage: 25,\n\tgreet() {\n\t\tconsole.log(`Hello, ${this.name}!`);\n\t}\n};",
    "def fibonacci(n):\n\tif n <= 1:\n\t\treturn n\n\treturn fibonacci(n-1) + fibonacci(n-2)",
    "func isEven(n int) bool {\n\treturn n%2 == 0\n}",
    "class Dog:\n\tdef __init__(self, name):\n\t\tself.name = name\n\tdef bark(self):\n\t\tprint('Woof!')",
    "const double = num => num * 2;",
    "int sum(int a, int b) {\n\treturn a + b;\n}",
    "def reverse_string(s):\n\treturn s[::-1]",
    "func max(a int, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}",
    "class Calculator {\n\tadd(a, b) {\n\t\treturn a + b;\n\t}\n\tsubtract(a, b) {\n\t\treturn a - b;\n\t}\n}",
    "const fruits = ['apple', 'banana', 'cherry'];\nfruits.forEach(fruit => console.log(fruit));",
    "def count_vowels(s):\n\tvowels = 'aeiou'\n\treturn sum(1 for char in s if char in vowels)",
    "func sumArray(arr []int) int {\n\tsum := 0\n\tfor _, num := range arr {\n\t\tsum += num\n\t}\n\treturn sum\n}",
    "class Rectangle {\n\tconstructor(width, height) {\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t}\n\tarea() {\n\t\treturn this.width * this.height;\n\t}\n}",
    "int max(int a, int b) {\n\treturn (a > b) ? a : b;\n}",
    "def is_palindrome(s):\n\treturn s == s[::-1]",
    "func factorial(n int) int {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\treturn n * factorial(n-1)\n}",
    "const isEven = num => num % 2 === 0;",
    "class Circle {\n\tconstructor(radius) {\n\t\tthis.radius = radius;\n\t}\n\tarea() {\n\t\treturn Math.PI * this.radius ** 2;\n\t}\n}",
    "int[] numbers = {1, 2, 3, 4, 5};\nfor (int num : numbers) {\n\tSystem.out.println(num);\n}",
    "def sum_of_squares(n):\n\treturn sum(i*i for i in range(1, n+1))",
    "func isPrime(n int) bool {\n\tif n <= 1 {\n\t\treturn false\n\t}\n\tfor i := 2; i*i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "const numbers = [1, 2, 3, 4, 5];\nconst evens = numbers.filter(num => num % 2 === 0);",
    "class Person {\n\tconstructor(name, age) {\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t}\n\tgreet() {\n\t\tconsole.log(`Hello, my name is ${this.name}`);\n\t}\n}",
    "int factorial(int n) {\n\tif (n == 0) {\n\t\treturn 1;\n\t}\n\treturn n * factorial(n - 1);\n}",
    "def count_words(s):\n\treturn len(s.split())",
    "func reverseArray(arr []int) []int {\n\tfor i, j := 0, len(arr)-1; i < j; i, j = i+1, j-1 {\n\t\tarr[i], arr[j] = arr[j], arr[i]\n\t}\n\treturn arr\n}",
    "const greet = name => `Hello, ${name}!`;",
    "class BankAccount {\n\tconstructor(balance) {\n\t\tthis.balance = balance;\n\t}\n\tdeposit(amount) {\n\t\tthis.balance += amount;\n\t}\n\twithdraw(amount) {\n\t\tthis.balance -= amount;\n\t}\n}",
    "int sumArray(int[] arr) {\n\tint sum = 0;\n\tfor (int num : arr) {\n\t\tsum += num;\n\t}\n\treturn sum;\n}",
    "def find_max(arr):\n\treturn max(arr)",
    "func countVowels(s string) int {\n\tvowels := \"aeiou\"\n\tcount := 0\n\tfor _, char := range s {\n\t\tif strings.ContainsRune(vowels, char) {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n}",
    "const numbers = [1, 2, 3, 4, 5];\nconst doubled = numbers.map(num => num * 2);",
    "class Student {\n\tconstructor(name, grade) {\n\t\tthis.name = name;\n\t\tthis.grade = grade;\n\t}\n\tpromote() {\n\t\tthis.grade++;\n\t}\n}",
    "int gcd(int a, int b) {\n\tif (b == 0) {\n\t\treturn a;\n\t}\n\treturn gcd(b, a % b);\n}",
    "def reverse_list(lst):\n\treturn lst[::-1]",
    "func sumDigits(n int) int {\n\tsum := 0\n\tfor n > 0 {\n\t\tsum += n % 10\n\t\tn /= 10\n\t}\n\treturn sum\n}",
    "const numbers = [1, 2, 3, 4, 5];\nconst sum = numbers.reduce((acc, num) => acc + num, 0);",
    "class Point {\n\tconstructor(x, y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\tdistanceToOrigin() {\n\t\treturn Math.sqrt(this.x ** 2 + this.y ** 2);\n\t}\n}",
    "int power(int base, int exponent) {\n\tif (exponent == 0) {\n\t\treturn 1;\n\t}\n\treturn base * power(base, exponent - 1);\n}",
    "def is_even(n):\n\treturn n % 2 == 0",
    "func isPalindrome(s string) bool {\n\tfor i := 0; i < len(s)/2; i++ {\n\t\tif s[i] != s[len(s)-1-i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
    "const numbers = [1, 2, 3, 4, 5];\nconst product = numbers.reduce((acc, num) => acc * num, 1);",
    "class Employee {\n\tconstructor(name, salary) {\n\t\tthis.name = name;\n\t\tthis.salary = salary;\n\t}\n\tgiveRaise(percent) {\n\t\tthis.salary *= (1 + percent / 100);\n\t}\n}",
    "int factorial(int n) {\n\tif (n == 0) {\n\t\treturn 1;\n\t}\n\treturn n * factorial(n - 1);\n}",
    "def count_characters(s):\n\treturn len(s)",
    "func findMax(arr []int) int {\n\tmax := arr[0]\n\tfor _, num := range arr {\n\t\tif num > max {\n\t\t\tmax = num\n\t\t}\n\t}\n\treturn max\n}",
    "const numbers = [1, 2, 3, 4, 5];\nconst evenNumbers = numbers.filter(num => num % 2 === 0);",
    "class Triangle {\n\tconstructor(base, height) {\n\t\tthis.base = base;\n\t\tthis.height = height;\n\t}\n\tarea() {\n\t\treturn (this.base * this.height) / 2;\n\t}\n}",
    "int sum(int a, int b) {\n\treturn a + b;\n}",
    "def is_odd(n):\n\treturn n % 2 != 0",
    "func reverseWords(s string) string {\n\twords := strings.Fields(s)\n\tfor i, j := 0, len(words)-1; i < j; i, j = i+1, j-1 {\n\t\twords[i], words[j] = words[j], words[i]\n\t}\n\treturn strings.Join(words, \" \")\n}",
    "const numbers = [1, 2, 3, 4, 5];\nconst maxNumber = Math.max(...numbers);",
    "class Bank {\n\tconstructor() {\n\t\tthis.accounts = [];\n\t}\n\taddAccount(account) {\n\t\tthis.accounts.push(account);\n\t}\n}",
    "boolean isPowerOfN(int n, int power) {\n\treturn n > 0 && Math.pow(power, Math.floor(Math.log(n) / Math.log(power))) == n;\n}",
    "def multiply_matrices(a, b):\n\treturn [[sum(a[i][k] * b[k][j] for k in range(len(b))) for j in range(len(b[0]))] for i in range(len(a))]",
        "const multiplyMatrices = (a, b) => a.map((row, i) => row.map((_, j) => row.reduce((sum, _, k) => sum + a[i][k] * b[k][j], 0)));",
        "func multiplyMatrices(a [][]int, b [][]int) [][]int {\n\tresult := make([][]int, len(a))\n\tfor i := range result {\n\t\tresult[i] = make([]int, len(b[0]))\n\t\tfor j := range result[i] {\n\t\t\tfor k := range b {\n\t\t\t\tresult[i][j] += a[i][k] * b[k][j]\n\t\t\t}\n\t\t}\n\t}\n\treturn result\n}",
        "int[][] multiplyMatrices(int[][] a, int[][] b) {\n\tint[][] result = new int[a.length][b[0].length];\n\tfor (int i = 0; i < a.length; i++) {\n\t\tfor (int j = 0; j < b[0].length; j++) {\n\t\t\tfor (int k = 0; k < b.length; k++) {\n\t\t\t\tresult[i][j] += a[i][k] * b[k][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}",
        "def transpose_matrix(matrix):\n\treturn [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]",
        "const transposeMatrix = matrix => matrix[0].map((_, i) => matrix.map(row => row[i]));",
        "func transposeMatrix(matrix [][]int) [][]int {\n\tresult := make([][]int, len(matrix[0]))\n\tfor i := range result {\n\t\tresult[i] = make([]int, len(matrix))\n\t\tfor j := range result[i] {\n\t\t\tresult[i][j] = matrix[j][i]\n\t\t}\n\t}\n\treturn result\n}",
        "int[][] transposeMatrix(int[][] matrix) {\n\tint[][] result = new int[matrix[0].length][matrix.length];\n\tfor (int i = 0; i < matrix[0].length; i++) {\n\t\tfor (int j = 0; j < matrix.length; j++) {\n\t\t\tresult[i][j] = matrix[j][i];\n\t\t}\n\t}\n\treturn result;\n}",
        "def flatten_list(lst):\n\treturn [item for sublist in lst for item in sublist]",
        "const flattenList = lst => lst.flat();",
        "func flattenList(lst [][]int) []int {\n\tvar result []int\n\tfor _, sublist := range lst {\n\t\tresult = append(result, sublist...)\n\t}\n\treturn result\n}",
        "List<Integer> flattenList(List<List<Integer>> lst) {\n\treturn lst.stream().flatMap(List::stream).collect(Collectors.toList());\n}",
        "def rotate_matrix(matrix):\n\treturn [list(row) for row in zip(*matrix[::-1])]",
        "const rotateMatrix = matrix => matrix[0].map((_, i) => matrix.map(row => row[i]).reverse());",
        "func rotateMatrix(matrix [][]int) [][]int {\n\tn := len(matrix)\n\tfor i := 0; i < n/2; i++ {\n\t\tfor j := i; j < n-i-1; j++ {\n\t\t\ttemp := matrix[i][j]\n\t\t\tmatrix[i][j] = matrix[n-j-1][i]\n\t\t\tmatrix[n-j-1][i] = matrix[n-i-1][n-j-1]\n\t\t\tmatrix[n-i-1][n-j-1] = matrix[j][n-i-1]\n\t\t\tmatrix[j][n-i-1] = temp\n\t\t}\n\t}\n\treturn matrix\n}",
        "int[][] rotateMatrix(int[][] matrix) {\n\tint n = matrix.length;\n\tfor (int i = 0; i < n / 2; i++) {\n\t\tfor (int j = i; j < n - i - 1; j++) {\n\t\t\tint temp = matrix[i][j];\n\t\t\tmatrix[i][j] = matrix[n - j - 1][i];\n\t\t\tmatrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];\n\t\t\tmatrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];\n\t\t\tmatrix[j][n - i - 1] = temp;\n\t\t}\n\t}\n\treturn matrix;\n}",
        "def binary_search(arr, target):\n\tlow, high = 0, len(arr) - 1\n\twhile low <= high:\n\t\tmid = (low + high) // 2\n\t\tif arr[mid] == target:\n\t\t\treturn mid\n\t\telif arr[mid] < target:\n\t\t\tlow = mid + 1\n\t\telse:\n\t\t\thigh = mid - 1\n\treturn -1",
        "const binarySearch = (arr, target) => {\n\tlet low = 0, high = arr.length - 1;\n\twhile (low <= high) {\n\t\tconst mid = Math.floor((low + high) / 2);\n\t\tif (arr[mid] === target) return mid;\n\t\tif (arr[mid] < target) low = mid + 1;\n\t\telse high = mid - 1;\n\t}\n\treturn -1;\n};",
        "func binarySearch(arr []int, target int) int {\n\tlow, high := 0, len(arr)-1\n\tfor low <= high {\n\t\tmid := (low + high) / 2\n\t\tif arr[mid] == target {\n\t\t\treturn mid\n\t\t} else if arr[mid] < target {\n\t\t\tlow = mid + 1\n\t\t} else {\n\t\t\thigh = mid - 1\n\t\t}\n\t}\n\treturn -1\n}",
        "int binarySearch(int[] arr, int target) {\n\tint low = 0, high = arr.length - 1;\n\twhile (low <= high) {\n\t\tint mid = (low + high) / 2;\n\t\tif (arr[mid] == target) return mid;\n\t\tif (arr[mid] < target) low = mid + 1;\n\t\telse high = mid - 1;\n\t}\n\treturn -1;\n}",
        "def merge_sort(arr):\n\tif len(arr) <= 1:\n\t\treturn arr\n\tmid = len(arr) // 2\n\tleft = merge_sort(arr[:mid])\n\tright = merge_sort(arr[mid:])\n\treturn merge(left, right)",
        "const mergeSort = arr => {\n\tif (arr.length <= 1) return arr;\n\tconst mid = Math.floor(arr.length / 2);\n\tconst left = mergeSort(arr.slice(0, mid));\n\tconst right = mergeSort(arr.slice(mid));\n\treturn merge(left, right);\n};",
        "func mergeSort(arr []int) []int {\n\tif len(arr) <= 1 {\n\t\treturn arr\n\t}\n\tmid := len(arr) / 2\n\tleft := mergeSort(arr[:mid])\n\tright := mergeSort(arr[mid:])\n\treturn merge(left, right)\n}",
        "int[] mergeSort(int[] arr) {\n\tif (arr.length <= 1) return arr;\n\tint mid = arr.length / 2;\n\tint[] left = mergeSort(Arrays.copyOfRange(arr, 0, mid));\n\tint[] right = mergeSort(Arrays.copyOfRange(arr, mid, arr.length));\n\treturn merge(left, right);\n}",
        "def merge(left, right):\n\tresult = []\n\ti = j = 0\n\twhile i < len(left) and j < len(right):\n\t\tif left[i] < right[j]:\n\t\t\tresult.append(left[i])\n\t\t\ti += 1\n\t\telse:\n\t\t\tresult.append(right[j])\n\t\t\tj += 1\n\tresult.extend(left[i:])\n\tresult.extend(right[j:])\n\treturn result",
        "const merge = (left, right) => {\n\tconst result = [];\n\tlet i = 0, j = 0;\n\twhile (i < left.length && j < right.length) {\n\t\tif (left[i] < right[j]) result.push(left[i++]);\n\t\telse result.push(right[j++]);\n\t}\n\treturn result.concat(left.slice(i)).concat(right.slice(j));\n};",
        "func merge(left, right []int) []int {\n\tresult := []int{}\n\ti, j := 0, 0\n\tfor i < len(left) && j < len(right) {\n\t\tif left[i] < right[j] {\n\t\t\tresult = append(result, left[i])\n\t\t\ti++\n\t\t} else {\n\t\t\tresult = append(result, right[j])\n\t\t\tj++\n\t\t}\n\t}\n\tresult = append(result, left[i:]...)\n\tresult = append(result, right[j:]...)\n\treturn result\n}",
        "int[] merge(int[] left, int[] right) {\n\tint[] result = new int[left.length + right.length];\n\tint i = 0, j = 0, k = 0;\n\twhile (i < left.length && j < right.length) {\n\t\tif (left[i] < right[j]) result[k++] = left[i++];\n\t\telse result[k++] = right[j++];\n\t}\n\twhile (i < left.length) result[k++] = left[i++];\n\twhile (j < right.length) result[k++] = right[j++];\n\treturn result;\n}",
        "def quick_sort(arr):\n\tif len(arr) <= 1:\n\t\treturn arr\n\tpivot = arr[len(arr) // 2]\n\tleft = [x for x in arr if x < pivot]\n\tmiddle = [x for x in arr if x == pivot]\n\tright = [x for x in arr if x > pivot]\n\treturn quick_sort(left) + middle + quick_sort(right)",
        "const quickSort = arr => {\n\tif (arr.length <= 1) return arr;\n\tconst pivot = arr[Math.floor(arr.length / 2)];\n\tconst left = arr.filter(x => x < pivot);\n\tconst middle = arr.filter(x => x === pivot);\n\tconst right = arr.filter(x => x > pivot);\n\treturn [...quickSort(left), ...middle, ...quickSort(right)];\n};",
        "func quickSort(arr []int) []int {\n\tif len(arr) <= 1 {\n\t\treturn arr\n\t}\n\tpivot := arr[len(arr)/2]\n\tvar left, middle, right []int\n\tfor _, x := range arr {\n\t\tif x < pivot {\n\t\t\tleft = append(left, x)\n\t\t} else if x == pivot {\n\t\t\tmiddle = append(middle, x)\n\t\t} else {\n\t\t\tright = append(right, x)\n\t\t}\n\t}\n\treturn append(append(quickSort(left), middle...), quickSort(right)...)\n}",
        "int[] quickSort(int[] arr) {\n\tif (arr.length <= 1) return arr;\n\tint pivot = arr[arr.length / 2];\n\tList<Integer> left = new ArrayList<>();\n\tList<Integer> middle = new ArrayList<>();\n\tList<Integer> right = new ArrayList<>();\n\tfor (int x : arr) {\n\t\tif (x < pivot) left.add(x);\n\t\telse if (x == pivot) middle.add(x);\n\t\telse right.add(x);\n\t}\n\tList<Integer> result = new ArrayList<>(quickSort(left.stream().mapToInt(i -> i).toArray()));\n\tresult.addAll(middle);\n\tresult.addAll(quickSort(right.stream().mapToInt(i -> i).toArray()));\n\treturn result.stream().mapToInt(i -> i).toArray();\n}"
  ]
}